name: Daily Check

on:
  schedule:
    # Runs every 30 minutes
    - cron: '*/30 * * * *'
  # Allow manual triggers for testing
  workflow_dispatch:

env:
  # Database configuration
  SUPABASE_URL: ${{ secrets.SUPABASE_URL }}
  SUPABASE_SERVICE_ROLE_KEY: ${{ secrets.SUPABASE_SERVICE_ROLE_KEY }}
  
  # LLM configuration
  GROQ_API_KEY: ${{ secrets.GROQ_API_KEY }}
  LLM_MODEL: 'llama-3.3-70b-versatile'
  LLM_TEMPERATURE: '0.7'
  LLM_MAX_TOKENS: '250'
  
  # Processing limits per workflow run (30 minutes)
  MAX_CONTACTS_PER_RUN: '70'      # Maximum total contacts to process per run
  PREMIUM_USER_RATIO: '0.7'       # 70% of slots for premium users
  
  # Batch configuration
  BATCH_SIZE: '10'                # Contacts per batch
  BATCH_DELAY: '20000'           # Milliseconds between batches (20s)
  CONTACT_DELAY: '2000'          # Milliseconds between each contact (2s)
  
  # Priority configuration
  MIN_RELATIONSHIP_LEVEL: '3'    # Minimum relationship level for priority
  MAX_MISSED_INTERACTIONS: '2'   # Process contacts with up to this many misses first

jobs:
  daily-check:
    runs-on: ubuntu-latest
    timeout-minutes: 30  # 30 minutes timeout

    steps:
      - uses: actions/checkout@v4
      
      - uses: actions/setup-node@v4
        with:
          node-version: '20'

      - name: Install dependencies
        run: |
          npm install @supabase/supabase-js axios

      - name: Process Contacts
        run: |
          node << 'EOF'
          const { createClient } = require('@supabase/supabase-js');
          const axios = require('axios');

          const GROQ_API_URL = 'https://api.groq.com/openai/v1/chat/completions';
          const BATCH_SIZE = parseInt(process.env.BATCH_SIZE);
          const BATCH_DELAY = parseInt(process.env.BATCH_DELAY);

          // Helper function to wait between batches
          const delay = ms => new Promise(resolve => setTimeout(resolve, ms));

          // Helper to get next contact date based on relationship level and frequency
          const getNextContactDate = (level, frequency, missedCount = 0) => {
            const baseDate = new Date();
            let days = 7; // Default to weekly

            if (frequency === 'daily') days = 1;
            else if (frequency === 'weekly') days = 7;
            else if (frequency === 'fortnightly') days = 14;
            else if (frequency === 'monthly') days = 30;
            else if (frequency === 'quarterly') days = 90;

            // Adjust frequency based on relationship level and missed count
            if (missedCount > 0) {
              days = Math.max(Math.floor(days / 2), 1); // Increase frequency but minimum 1 day
            }

            baseDate.setDate(baseDate.getDate() + days);
            return baseDate;
          };

          async function processMissedInteractions(supabase, today, todayEnd) {
            console.log('Processing missed interactions...');
            const { data: missedContacts, error: missedError } = await supabase
              .from('contacts')
              .select('*')
              .gte('next_contact_due', today.toISOString())
              .lte('next_contact_due', todayEnd.toISOString());

            if (missedError) throw missedError;

            for (const contact of missedContacts || []) {
              const { data: latestInteraction } = await supabase
                .from('interactions')
                .select('date')
                .eq('contact_id', contact.id)
                .order('date', { ascending: false })
                .limit(1)
                .single();

              const todayStart = new Date();
              todayStart.setHours(0, 0, 0, 0);
              const dueDate = new Date(contact.next_contact_due);
              dueDate.setHours(0, 0, 0, 0);

              if (dueDate.getTime() === todayStart.getTime() && 
                  (!latestInteraction || 
                   new Date(latestInteraction.date).setHours(0, 0, 0, 0) < todayStart.getTime())) {
                
                const nextContactDue = getNextContactDate(
                  contact.relationship_level,
                  contact.contact_frequency,
                  (contact.missed_interactions || 0) + 1
                );

                await supabase
                  .from('contacts')
                  .update({
                    missed_interactions: (contact.missed_interactions || 0) + 1,
                    next_contact_due: nextContactDue.toISOString()
                  })
                  .eq('id', contact.id);

                // Update reminder
                await supabase.from('reminders').delete().eq('contact_id', contact.id);
                await supabase.from('reminders').insert({
                  contact_id: contact.id,
                  user_id: contact.user_id,
                  type: contact.preferred_contact_method || 'message',
                  due_date: nextContactDue.toISOString(),
                  description: contact.notes || undefined
                });
              }
            }
          }

          async function processContactBatch(supabase, contacts, tomorrow) {
            const tomorrowStr = tomorrow.toISOString().split('T')[0];
            
            for (const contact of contacts) {
              try {
                console.log(`Processing contact ${contact.id}...`);
                
                const timeSinceLastContact = contact.last_contacted
                  ? Math.floor((Date.now() - new Date(contact.last_contacted).getTime()) / (1000 * 60 * 60 * 24))
                  : null;

                const userMessage = [
                  "Analyze this contact's information and provide 2-3 highly impactful suggestions to strengthen the relationship:",
                  "",
                  "Contact Details:",
                  `- Name: ${contact.name}`,
                  `- Last contacted: ${timeSinceLastContact ? timeSinceLastContact + " days ago" : "Never"}`,
                  `- Preferred method: ${contact.preferred_contact_method || "Not specified"}`,
                  `- Preferred contact frequency: ${contact.contact_frequency || "Not specified"}`,          
                  `- Relationship level: ${contact.relationship_level}/5`,
                  `- Notes: ${contact.notes || "None"}`,
                  "",
                  "Recent Activity (chronological):",
                  `${(contact.interactions || [])
                    .sort((a, b) => new Date(a.date).getTime() - new Date(b.date).getTime())
                    .map(i => `- ${new Date(i.date).toLocaleDateString()}: ${i.type} (${i.sentiment || "neutral"})`).join('\n') || 'None'}`,
                  "",
                  "Rules for Suggestions:",
                  "1. Must be specific to their context and personal details — no generic advice",
                  "2. Must be actionable within 24-48 hours",
                  "3. Must clearly contribute to relationship growth",
                  "4. Each suggestion should start with \"[type: call/message/social]\"",
                  "5. Keep suggestions concise and impactful",
                  "6. If no clear opportunities exist, return no suggestions",
                  "",
                  "Provide ONLY the most impactful 1-2 suggestions, each on a new line starting with \"•\""
                ].join('\n');

                // Check subscription status
                const { data: subscription } = await supabase
                  .from('subscriptions')
                  .select('plan_id, valid_until')
                  .eq('user_id', contact.user_id)
                  .single();

                const isPremium = subscription?.plan_id === 'premium' &&
                  subscription.valid_until &&
                  new Date(subscription.valid_until) > new Date();

                let suggestions;
                if (isPremium) {
                  try {
                    // Add delay between contacts to avoid rate limits
                    await delay(parseInt(process.env.CONTACT_DELAY));

                    const groqResponse = await axios.post(
                      GROQ_API_URL,
                      {
                        model: process.env.LLM_MODEL,
                        messages: [
                          {
                            role: 'system',
                            content: 'You are a relationship manager assistant helping users maintain meaningful connections.'
                          },
                          {
                            role: 'user',
                            content: userMessage
                          }
                        ],
                        temperature: parseFloat(process.env.LLM_TEMPERATURE),
                        max_tokens: parseInt(process.env.LLM_MAX_TOKENS)
                      },
                      {
                        headers: {
                          'Authorization': `Bearer ${process.env.GROQ_API_KEY}`,
                          'Content-Type': 'application/json'
                        }
                      }
                    );

                    suggestions = groqResponse.data.choices[0].message.content;
                    console.log(`LLM request successful for contact ${contact.id}`);
                  } catch (error) {
                    const errorMsg = error.response?.data?.error?.message || error.message;
                    console.error(`LLM API error for contact ${contact.id}:`, errorMsg);
                    throw new Error(`LLM API error: ${errorMsg}`);
                  }
                } else {
                  suggestions = '<div class="bg-yellow-50 p-3 rounded-lg"><strong>Important:</strong> Upgrade to premium to get advanced AI suggestions!</div>';
                }

                // Update contact with suggestions
                const [updateResult, logResult] = await Promise.all([
                  supabase
                    .from('contacts')
                    .update({
                      ai_last_suggestion: suggestions,
                      ai_last_suggestion_date: new Date().toISOString()
                    })
                    .eq('id', contact.id),
                  supabase
                    .from('contact_processing_logs')
                    .insert({
                      contact_id: contact.id,
                      processing_date: tomorrowStr,
                      batch_id: new Date().toISOString(), // Track which batch processed this contact
                      status: 'success'
                    })
                ]);

                if (updateResult.error) throw updateResult.error;
                if (logResult.error) throw logResult.error;

                console.log(`Successfully processed contact ${contact.id}`);
              } catch (error) {
                console.error(`Error processing contact ${contact.id}:`, error);
                
                // Log error in processing logs
                await supabase
                  .from('contact_processing_logs')
                  .insert({
                    contact_id: contact.id,
                    processing_date: tomorrowStr,
                    batch_id: new Date().toISOString(),
                    status: 'error',
                    error_message: error.message
                  });
              }
            }
          }

          async function main() {
            try {
              const supabase = createClient(
                process.env.SUPABASE_URL,
                process.env.SUPABASE_SERVICE_ROLE_KEY,
                { auth: { persistSession: false, autoRefreshToken: false } }
              );

              // Get date ranges
              const today = new Date();
              today.setHours(0, 0, 0, 0);
              const todayEnd = new Date(today);
              todayEnd.setHours(23, 59, 59, 999);

              // Process missed interactions from today
              await processMissedInteractions(supabase, today, todayEnd);

              // Tomorrow's date range for new reminders
              const tomorrow = new Date(today);
              tomorrow.setDate(tomorrow.getDate());
              tomorrow.setHours(12, 0, 0, 0);
              const tomorrowEnd = new Date(tomorrow);
              tomorrowEnd.setDate(tomorrowEnd.getDate() + 1);
              tomorrowEnd.setHours(12, 0, 0, 0);

              // Get contacts that need processing
              const { data: contacts, error: contactsError } = await supabase
                .from('contacts')
                .select(`
                  id,
                  user_id,
                  name,
                  last_contacted,
                  next_contact_due,
                  preferred_contact_method,
                  relationship_level,
                  contact_frequency,
                  social_media_handle,
                  notes,
                  missed_interactions,
                  interactions (
                    type,
                    date,
                    sentiment
                  )
                `)
                .gte('next_contact_due', tomorrow.toISOString())
                .lte('next_contact_due', tomorrowEnd.toISOString());

              if (contactsError) throw contactsError;
              if (!contacts?.length) {
                console.log('No contacts need attention');
                return;
              }

              // Filter out already processed contacts
              const tomorrowStr = tomorrow.toISOString().split('T')[0];
              const { data: processedContacts } = await supabase
                .from('contact_processing_logs')
                .select('contact_id')
                .eq('processing_date', tomorrowStr);

              const processedIds = new Set((processedContacts || []).map(p => p.contact_id));
              let unprocessedContacts = contacts.filter(c => !processedIds.has(c.id));

              if (!unprocessedContacts.length) {
                console.log('No unprocessed contacts need attention');
                return;
              }

              // Get subscription status for all users
              const { data: subscriptions } = await supabase
                .from('subscriptions')
                .select('user_id, plan_id, valid_until');

              const premiumUserIds = new Set(
                subscriptions
                  ?.filter(s =>
                    s.plan_id === 'premium' &&
                    s.valid_until &&
                    new Date(s.valid_until) > new Date()
                  )
                  .map(s => s.user_id) || []
              );

              // Split contacts by subscription and sort by priority
              const premiumContacts = unprocessedContacts
                .filter(c => premiumUserIds.has(c.user_id))
                .sort((a, b) => {
                  // Sort by relationship level and missed interactions
                  const aScore = (a.relationship_level >= parseInt(process.env.MIN_RELATIONSHIP_LEVEL) ? 2 : 0) +
                                (a.missed_interactions <= parseInt(process.env.MAX_MISSED_INTERACTIONS) ? 1 : 0);
                  const bScore = (b.relationship_level >= parseInt(process.env.MIN_RELATIONSHIP_LEVEL) ? 2 : 0) +
                                (b.missed_interactions <= parseInt(process.env.MAX_MISSED_INTERACTIONS) ? 1 : 0);
                  return bScore - aScore;
                });

              const freeContacts = unprocessedContacts
                .filter(c => !premiumUserIds.has(c.user_id))
                .sort((a, b) =>
                  // For free users, prioritize by missed interactions
                  (b.missed_interactions || 0) - (a.missed_interactions || 0)
                );

              // Calculate slots for each tier
              const maxContacts = parseInt(process.env.MAX_CONTACTS_PER_RUN);
              const premiumRatio = parseFloat(process.env.PREMIUM_USER_RATIO);
              const premiumSlots = Math.floor(maxContacts * premiumRatio);
              const freeSlots = maxContacts - Math.min(premiumContacts.length, premiumSlots);

              // Select contacts to process this run
              const contactsToProcess = [
                ...premiumContacts.slice(0, premiumSlots),
                ...freeContacts.slice(0, freeSlots)
              ];

              // Process in batches
              const batchSize = parseInt(process.env.BATCH_SIZE);
              const batchDelay = parseInt(process.env.BATCH_DELAY);

              for (let i = 0; i < contactsToProcess.length; i += batchSize) {
                const batch = contactsToProcess.slice(i, i + batchSize);
                console.log(`Processing batch ${i/batchSize + 1} of ${Math.ceil(contactsToProcess.length/batchSize)}`);
                
                await processContactBatch(supabase, batch, tomorrow);
                
                // Delay between batches if there are more to process
                if (i + batchSize < contactsToProcess.length) {
                  console.log(`Waiting ${batchDelay}ms before next batch...`);
                  await delay(batchDelay);
                }
              }

              console.log('Daily check completed successfully');
            } catch (error) {
              console.error('Error in daily check:', error);
              process.exit(1);
            }
          }

          main();
          EOF              const freeContacts = unprocessedContacts.filter(c => !premiumUserIds.has(c.user_id));

              // Process premium users first, up to the limit
              let contactsToProcess = [
