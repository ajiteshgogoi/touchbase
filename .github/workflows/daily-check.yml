name: Daily Check

on:
  schedule:
    # Runs every 30 minutes
    - cron: '*/30 * * * *'
  # Allow manual triggers for testing
  workflow_dispatch:

jobs:
  daily-check:
    runs-on: ubuntu-latest
    timeout-minutes: 30

    steps:
      - name: Checkout repository
        uses: actions/checkout@v4

      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: '20'

      - name: Install dependencies
        run: npm install @supabase/supabase-js axios

      - name: Run Daily Check
        env:
          SUPABASE_URL: ${{ secrets.SUPABASE_URL }}
          SUPABASE_SERVICE_ROLE_KEY: ${{ secrets.SUPABASE_SERVICE_ROLE_KEY }}
          GROQ_API_KEY: ${{ secrets.GROQ_API_KEY }}
          # URL for the Groq API or alternative LLM service (e.g. OpenAI, Anthropic)
          # Default: https://api.groq.com/openai/v1/chat/completions
          LLM_API_URL: ${{ secrets.LLM_API_URL || 'https://api.groq.com/openai/v1/chat/completions' }}
          # Model to use for generating suggestions. Choose a model that supports chat completions
          # Default: llama-3.3-70b-versatile
          LLM_MODEL: ${{ secrets.LLM_MODEL || 'llama-3.3-70b-versatile' }}
        run: |
          node -e '
          const { createClient } = require("@supabase/supabase-js");
          const axios = require("axios");

          // Configurable LLM service variables
          const LLM_API_URL = process.env.LLM_API_URL;
          const LLM_MODEL = process.env.LLM_MODEL;

          async function run() {
            try {
              if (!process.env.SUPABASE_URL || !process.env.SUPABASE_SERVICE_ROLE_KEY || !process.env.GROQ_API_KEY) {
                throw new Error("Missing required environment variables");
              }

              const supabaseClient = createClient(
                process.env.SUPABASE_URL,
                process.env.SUPABASE_SERVICE_ROLE_KEY,
                {
                  auth: {
                    persistSession: false,
                    autoRefreshToken: false
                  }
                }
              );

              // Get today"s date range
              const today = new Date();
              today.setHours(0, 0, 0, 0);
              const todayEnd = new Date(today);
              todayEnd.setHours(23, 59, 59, 999);

              // Tomorrow"s date range for new reminders
              const tomorrow = new Date(today);
              tomorrow.setDate(tomorrow.getDate());
              tomorrow.setHours(12, 0, 0, 0);
              const tomorrowEnd = new Date(tomorrow);
              tomorrowEnd.setDate(tomorrowEnd.getDate() + 1);
              tomorrowEnd.setHours(12, 0, 0, 0);

              console.log("Checking for tomorrow\"s contacts between:", tomorrow.toISOString(), "and", tomorrowEnd.toISOString());

              // First, handle missed interactions from today
              const { data: missedContacts, error: missedError } = await supabaseClient
                .from("contacts")
                .select(`
                  id,
                  missed_interactions,
                  relationship_level,
                  contact_frequency
                `)
                .gte("next_contact_due", today.toISOString())
                .lte("next_contact_due", todayEnd.toISOString());

              if (missedError) throw missedError;

              if (missedContacts && missedContacts.length > 0) {
                await Promise.all(missedContacts.map(async (contact) => {
                  const { data: latestInteraction } = await supabaseClient
                    .from("interactions")
                    .select("date")
                    .eq("contact_id", contact.id)
                    .order("date", { ascending: false })
                    .limit(1)
                    .single();

                  const { data: fullContact } = await supabaseClient
                    .from("contacts")
                    .select("*")
                    .eq("id", contact.id)
                    .single();

                  if (!fullContact) {
                    console.error("Contact not found:", contact.id);
                    return;
                  }

                  const today = new Date();
                  today.setHours(0, 0, 0, 0);
                  const dueDate = new Date(fullContact.next_contact_due);
                  dueDate.setHours(0, 0, 0, 0);

                  if (dueDate.getTime() === today.getTime() &&
                      (!latestInteraction ||
                       new Date(latestInteraction.date).setHours(0, 0, 0, 0) < today.getTime())) {
                    try {
                      const nextContactDue = getNextContactDate(
                        fullContact.relationship_level,
                        fullContact.contact_frequency,
                        (fullContact.missed_interactions || 0) + 1
                      );

                      await supabaseClient
                        .from("contacts")
                        .update({
                          missed_interactions: (fullContact.missed_interactions || 0) + 1,
                          next_contact_due: nextContactDue.toISOString()
                        })
                        .eq("id", contact.id);

                      await supabaseClient
                        .from("reminders")
                        .delete()
                        .eq("contact_id", contact.id);

                      await supabaseClient.from("reminders").insert({
                        contact_id: contact.id,
                        user_id: fullContact.user_id,
                        type: fullContact.preferred_contact_method || "message",
                        due_date: nextContactDue.toISOString(),
                        description: fullContact.notes || undefined
                      });
                    } catch (error) {
                      console.error("Error handling missed interaction:", error);
                    }
                  }
                }));
              }

              // Get all contacts that need attention tomorrow
              const { data: contacts, error: contactsError } = await supabaseClient
                .from("contacts")
                .select(`
                  id,
                  user_id,
                  name,
                  last_contacted,
                  next_contact_due,
                  preferred_contact_method,
                  relationship_level,
                  contact_frequency,
                  social_media_handle,
                  notes,
                  missed_interactions,
                  interactions (
                    type,
                    date,
                    sentiment
                  )
                `)
                .gte("next_contact_due", tomorrow.toISOString())
                .lte("next_contact_due", tomorrowEnd.toISOString());

              if (contactsError) {
                console.error("Error fetching tomorrow's contacts:", contactsError);
                throw contactsError;
              }

              console.log('Found contacts for tomorrow:', contacts?.length || 0);
              if (contacts?.length) {
                console.log('Contact due dates:', contacts.map(c => ({
                  id: c.id,
                  name: c.name,
                  next_contact_due: c.next_contact_due
                })));
              } else {
                console.log("No contacts need attention");
                return;
              }

              // Get already processed contacts for tomorrow
              const tomorrowStr = tomorrow.toISOString().split("T")[0];
              console.log("Checking processed contacts for date:", tomorrowStr);
              
              const { data: processedContacts, error: processedError } = await supabaseClient
                .from("contact_processing_logs")
                .select("contact_id")
                .eq("processing_date", tomorrowStr);

              if (processedError) {
                console.error("Error fetching processed contacts:", processedError);
                throw processedError;
              }

              // Filter out already processed contacts
              const processedContactIds = new Set((processedContacts || []).map(p => p.contact_id));
              const unprocessedContacts = contacts.filter(c => !processedContactIds.has(c.id));

              if (!unprocessedContacts || unprocessedContacts.length === 0) {
                console.log("No unprocessed contacts need attention");
                return;
              }

              // Process each unprocessed contact
              const processResults = await Promise.all(unprocessedContacts.map(async (contact) => {
                try {
                  const timeSinceLastContact = contact.last_contacted
                    ? Math.floor((Date.now() - new Date(contact.last_contacted).getTime()) / (1000 * 60 * 60 * 24))
                    : null;

                  const userMessage = [
                    "Analyze this contact's information and provide 2-3 highly impactful suggestions to strengthen the relationship:",
                    "",
                    "Contact Details:",
                    `- Name: ${contact.name}`,
                    `- Last contacted: ${timeSinceLastContact ? timeSinceLastContact + " days ago" : "Never"}`,
                    `- Preferred method: ${contact.preferred_contact_method || "Not specified"}`,
                    `- Preferred contact frequency: ${contact.contact_frequency || "Not specified"}`,          
                    `- Relationship level: ${contact.relationship_level}/5`,
                    `- Notes: ${contact.notes || "None"}`,
                    "",
                    "Recent Activity (chronological):",
                    `${(contact.interactions || [])
                      .sort((a, b) => new Date(a.date).getTime() - new Date(b.date).getTime())
                      .map(i => `- ${new Date(i.date).toLocaleDateString()}: ${i.type} (${i.sentiment || "neutral"})${i.notes ? `\n  Notes: ${i.notes}` : ''}`).join("\n") || "None"}`,
                    "",
                    "Rules for Suggestions:",
                    "1. Must be specific to their context and personal details — no generic advice",
                    "2. Must be actionable within 24-48 hours",
                    "3. Must clearly contribute to relationship growth",
                    "4. Each suggestion should start with \"[type: call/message/social]\"",
                    "5. Keep suggestions concise and impactful",
                    "6. If no clear opportunities exist, return no suggestions",
                    "",
                    "Provide ONLY the most impactful 1-2 suggestions, each on a new line starting with \"•\""
                  ].join("\n");

                  // Check subscription status
                  const { data: subscription, error: subError } = await supabaseClient
                    .from("subscriptions")
                    .select("plan_id, valid_until")
                    .eq("user_id", contact.user_id)
                    .single();

                  if (subError) {
                    console.error("Error fetching subscription:", subError);
                    throw subError;
                  }

                  const isPremium = subscription?.plan_id === "premium" &&
                    subscription.valid_until &&
                    new Date(subscription.valid_until) > new Date();

                  let suggestions;
                  if (isPremium) {
                    try {
                      console.log("Making Groq API request for contact:", contact.id);
                      const groqResponse = await axios.post(
                       LLM_API_URL,
                       {
                         model: LLM_MODEL,
                          messages: [
                            {
                              role: "system",
                              content: "You are a relationship manager assistant helping users maintain meaningful connections."
                            },
                            {
                              role: "user",
                              content: userMessage
                            }
                          ],
                          temperature: 0.7,
                          max_tokens: 250
                        },
                        {
                          headers: {
                            "Authorization": `Bearer ${process.env.GROQ_API_KEY}`,
                            "Content-Type": "application/json"
                          }
                        }
                      );

                      if (!groqResponse.data?.choices?.[0]?.message?.content) {
                        throw new Error("Invalid response structure from Groq API: " + JSON.stringify(groqResponse.data));
                      }

                      suggestions = groqResponse.data.choices[0].message.content;
                    } catch (groqError) {
                      console.error("Groq API error:", groqError);
                      throw new Error(`Groq API error: ${groqError.message || 'Unknown error'} - ${groqError.response?.data ? JSON.stringify(groqError.response.data) : 'No response data'}`);
                    }
                  } else {
                    suggestions = "<div class=\"bg-yellow-50 p-3 rounded-lg\"><strong>Important:</strong> Upgrade to premium to get advanced AI suggestions!</div>";
                  }

                  // Determine suggested contact method based on relationship level and missed interactions
                  const getSuggestedMethod = (level: number, preferred: string | null, missedInteractions: number) => {
                    if (missedInteractions >= 3) {
                      return "call";
                    } else if (missedInteractions >= 2) {
                      return preferred === "call" ? "call" : "message";
                    }

                    if (level >= 4) {
                      return "call";
                    } else if (level >= 2) {
                      return preferred || "message";
                    }
                    return "message";
                  };

                  const suggestedMethod = getSuggestedMethod(contact.relationship_level, contact.preferred_contact_method, contact.missed_interactions || 0);

                  // Update contact with AI suggestion and log processing
                  const [updateResult, logResult] = await Promise.all([
                    supabaseClient
                      .from("contacts")
                      .update({
                        ai_last_suggestion: suggestions,
                        ai_last_suggestion_date: new Date().toISOString()
                      })
                      .eq("id", contact.id),
                    supabaseClient
                      .from("contact_processing_logs")
                      .insert({
                        contact_id: contact.id,
                        processing_date: tomorrowStr
                      })
                  ]);

                  if (updateResult.error) throw updateResult.error;
                  if (logResult.error) throw logResult.error;

                  return {
                    contactId: contact.id,
                    status: "success"
                  };
                } catch (error) {
                  console.error("Error processing contact:", error);
                  return {
                    contactId: contact.id,
                    status: "error",
                    error: error.message || "Unknown error",
                    details: JSON.stringify(error)
                  };
                }
              }));

              console.log("Daily check completed:", processResults);
            } catch (error) {
              console.error("Error in daily check:", error);
              process.exit(1);
            }
          }

          run();
          '